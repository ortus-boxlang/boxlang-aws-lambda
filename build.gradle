// https://docs.gradle.org/current/userguide/building_java_projects.html#sec:java_packaging
plugins {
    id 'java'
    // For source code formatting
    id "com.diffplug.spotless" version "6.25.0"
	// https://github.com/harbby/gradle-serviceloader
    id "com.github.harbby.gradle.serviceloader" version "1.1.8"
	// https://github.com/johnrengelman/shadow
	id 'com.github.johnrengelman.shadow' version '8.1.1'
    // Download task
    id "de.undercouch.download" version "5.6.0"
}

/**
 * Project Properties
 */
ext {
	buildID = System.getenv( 'BUILD_ID' ) ?: '0'
	branch = System.getenv( 'BRANCH' ) ?: 'development'
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
	// Until BoxLang is published to Maven Central
	// Look for it in the local build directory
	// You must run `./gradle build -x test` in the BoxLang project
    implementation files( 'src/test/resources/libs/boxlang-1.0.0-all.jar' )
	implementation 'com.amazonaws:aws-lambda-java-core:1.2.3'
    implementation 'org.slf4j:slf4j-nop:2.0.6'

    // Testing Dependencies
    testImplementation "org.junit.jupiter:junit-jupiter:5.+"
	testImplementation "org.mockito:mockito-core:5.+"
	testImplementation "com.google.truth:truth:1.+"
}

java {
	// See: https://docs.gradle.org/current/userguide/toolchains.html#toolchains
    // This is to provide build consistency across developers and CI/CD
    toolchain {
        languageVersion = JavaLanguageVersion.of( project.properties[ "jdkVersion" ] )
    }
    // Produces a javadocs jar
	withJavadocJar()
}

compileJava {
	// Compiler Options
	options.incremental = true
	options.release = Integer.parseInt( project.properties[ "jdkVersion" ] )
	options.encoding = 'UTF-8'
	options.debug()
}

javadoc {
    // To avoid our own doclet issues
	options.addBooleanOption( "Xdoclint:none", true )
	//exclude '**/boxlang/parser/**'
	options.addBooleanOption( 'html5', true )
}
task zipJavadocs( type: Zip ) {
	group "documentation"
	from javadoc.destinationDir
	archiveFileName = "${project.name}-javadocs-${version}.zip"
	destinationDirectory = file( "$buildDir/distributions" )
	// Output that the docs have been zippped
	doLast {
		println "+ Javadocs have been zipped to the distribution folder"
	}
}
javadoc.finalizedBy( zipJavadocs )

jar {
    archiveVersion =  "${version}"
 	manifest {
	   attributes 'Description': 'The BoxLang AWS Lambda Runtime'
    }
}
shadowJar {
    destinationDirectory = file( "build/distributions" )
	exclude "schema/**"
	exclude "io/undertow/**"
	exclude "org/jboss/**"
	exclude "org/wildfly/**"
	exclude "org/xnio/**"
	exclude "dump/html/**"
	exclude "ortus/boxlang/debugger/**"
	exclude "ortus/boxlang/web/**"
	exclude "org/antlr/v4/gui/**"
	exclude "org/antlr/v4/gui/**"
}
build.finalizedBy( shadowJar )

/**
 * Source Code Formatting
 */
spotless {
    java {
		target fileTree( "." ) {
            include "**/*.java"
            exclude "**/build/**", "bin/**", "examples/**"
        }
        eclipse().configFile( "./.ortus-java-style.xml" )
		toggleOffOn()
    }
}

task buildTestZip( type: Zip ) {
	archiveFileName = "${project.name}-test-${version}.zip"
	from 'src/test/resources/Lambda.bx'
	into( 'lib' ) {
		from shadowJar.outputs.files
	}
}
shadowJar.finalizedBy( buildTestZip )

test {
    useJUnitPlatform()
    testLogging {
		showStandardStreams = true
	}
}

/**
 * TEMPORARY until we publish to maven
 * Task to download the latest jar from https://ortus-temp.s3.amazonaws.com/jericho/libs/boxlang-1.0.0-all.jar
 */
task downloadBoxLang( type: Download ) {
	// Create the destination directory
	doFirst {
		file( "src/test/resources/libs" ).mkdirs()
	}
    // Configure the URL of the file to download
    src "https://ortus-temp.s3.amazonaws.com/jericho/libs/boxlang-${boxlangVersion}-all.jar"
    // Specify the destination directory for the downloaded file
    dest "src/test/resources/libs/boxlang-${boxlangVersion}-all.jar"
    overwrite true
    onlyIfModified false
}

/**
 * Project Wide Helper function
 * This is not a task, but a reusable UDF
 */
project.ext.bumpVersion = { boolean major = false, boolean minor = false, boolean patch = false ->

	def propertiesFile = file( '../gradle.properties' );
	def properties = new Properties();

	properties.load( propertiesFile.newDataInputStream() )
	def versionTarget = major ? 0 : minor ? 1 : 2

	def currentVersion = properties.getProperty( 'version' )
	def versionParts = currentVersion.split( '\\.' )
	def newPathVersion = versionParts[ versionTarget ].toInteger() + 1
	def newVersion = '';

	if( patch ){
		newVersion = "${versionParts[ 0 ]}.${versionParts[ 1 ]}.${newPathVersion}"
	} else if( minor ){
		newVersion = "${versionParts[ 0 ]}.${newPathVersion}.${versionParts[ 2 ]}"
	} else if( major ){
		newVersion = "${newPathVersion}.${versionParts[ 1 ]}.${versionParts[ 2 ]}"
	}

	properties.setProperty( 'version', newVersion )
	properties.store( propertiesFile.newWriter(), null )

	println "Bumped version from ${currentVersion} to ${newVersion}"
}
/**
 * Bump the major version number
 */
task bumpMajorVersion {
	doLast{
		bumpVersion( true )
	}
}

/**
 * Bump the minor version number
 */
task bumpMinorVersion {
	doLast{
		bumpVersion( false, true )
	}
}

/**
 * Bump the patch version number
 */
task bumpPatchVersion {
	doLast{
		bumpVersion( false, false, true )
	}
}
